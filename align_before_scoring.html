<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Word Transcription with Scrolling</title>
<script src="https://unpkg.com/wavesurfer.js"></script>
<style>
:root{
  --gap: 34vw;
  --scale-center: 1.2;
  --scale-side: 0.92;
  --duration: 420ms; 
  --font-size: 60pt;
  --bg: #0b0b0b;
  --fg: #fff;
  --muted: #bbb;
}

html,body{
  height:100%; margin:0; background:var(--bg); color:var(--fg);
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
}

.stage{
  height:60vh; display:flex; align-items:center; justify-content:center;
  overflow:hidden; position:relative;
}

.slot{
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  white-space:nowrap; font-size:var(--font-size);
  transition: transform var(--duration) cubic-bezier(.2,.9,.2,1),
              opacity var(--duration) cubic-bezier(.2,.9,.2,1);
  pointer-events:none;
}

.slot.side { color: var(--muted); }
.slot.blank { opacity: 0.3; }

.pos-left   { transform: translate(calc(-50% - var(--gap)), -50%) scale(var(--scale-side)); opacity:0.55; }
.pos-center { transform: translate(-50%,-50%) scale(var(--scale-center)); opacity:1; }
.pos-right  { transform: translate(calc(-50% + var(--gap)), -50%) scale(var(--scale-side)); opacity:0.55; }
.pos-off-right { transform: translate(calc(100vw), -50%) scale(var(--scale-side)); opacity:0; }
.pos-off-left  { transform: translate(calc(-100vw), -50%) scale(var(--scale-side)); opacity:0.12; }

.controls {
  position:fixed; left:50%; transform:translateX(-50%);
  bottom:18px; text-align:center; color:#cfcfcf; font-size:13px;
  background: rgba(255,255,255,0.02); padding:8px 12px; border-radius:10px; backdrop-filter: blur(4px);
}
.controls input[type=range] { width:320px; vertical-align:middle; margin-left:10px; }
#log {
  position:fixed; bottom:120px; left:0; right:0;
  max-height:25vh; overflow-y:auto; background:#111; color:#fff;
  border-top:1px solid #444; padding:0.5rem;
  font-size:14px;
}
.batch-entry {
  background: rgba(255,165,0,0.1);
  border-left: 3px solid #ffa500;
  padding: 10px;
  margin: 10px 0;
  display: flex;
  align-items: center;
  gap: 15px;
}
.playBtn { 
  cursor:pointer; 
  padding: 8px 12px;
  font-size: 14px;
  background: #ffa500;
  border: none;
  border-radius: 5px;
  color: #000;
  font-weight: bold;
}
.waveform { 
  flex: 1;
  height: 80px;
  min-width: 300px;
}
.batch-title {
  font-weight: bold;
  color: #ffa500;
  min-width: 200px;
}
button:disabled { opacity: 0.4; cursor: not-allowed; }
.status { 
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
  font-size: 14px;
}
.progress {
  position: fixed;
  top: 60px;
  left: 50%;
  transform: translateX(-50%);
  color: #cfcfcf;
  font-size: 12px;
}
.batch-indicator {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  color: #ffa500;
  font-size: 12px;
}
/* Transcription table styles */
.transcription-table {
  width: 100%;
  margin-top: 10px;
  border-collapse: collapse;
  font-size: 12px;
}

.transcription-table th,
.transcription-table td {
  border: 1px solid #444;
  padding: 4px 8px;
  text-align: left;
}

.transcription-table th {
  background: rgba(255,165,0,0.2);
  color: #ffa500;
}

.transcription-table .word-cell {
  min-width: 80px;
}

.transcription-table .time-cell {
  min-width: 60px;
  font-family: monospace;
}

.transcription-loading {
  color: #ffa500;
  margin: 10px 0;
  font-size: 14px;
}

.batch-score {
  font-weight: bold;
  margin: 10px 0;
  padding: 5px 10px;
  border-radius: 5px;
  text-align: center;
}

.score-perfect {
  background: rgba(0, 255, 0, 0.2);
  color: #4CAF50;
}

.score-good {
  background: rgba(255, 255, 0, 0.2);
  color: #FFC107;
}

.score-poor {
  background: rgba(255, 0, 0, 0.2);
  color: #F44336;
}
</style>
</head>
<body>

<div class="stage" id="stage"></div>

<div class="controls">
  RMS threshold: <strong id="tval">0.05</strong>
  <input id="threshold" type="range" min="0.01" max="0.35" step="0.005" value="0.05">
  <button id="sendBatch">üì§ Send Full Audio</button>
</div>

<div id="log"></div>

<script>
// Modified words array with blank entries for batch separation
const originalWords = (`uhe aha uho ohi ahe ahi oha eho uhu iha aha uhi iha ihe uho
ihu uhe eho oha uhi oha eha ihi ihi eho uhi uhe ihe ohi oha`).split(/\s+/);

// Create modified word list with blank entries every 5 words
const words = [];
for (let i = 0; i < originalWords.length; i++) {
  words.push(originalWords[i]);
  if ((i + 1) % 5 === 0 && i < originalWords.length - 1) {
    words.push(""); // Insert blank word
  }
}

const stage = document.getElementById('stage');
const thresholdSlider = document.getElementById('threshold');
const tval = document.getElementById('tval');
const logDiv = document.getElementById('log');
const sendBatchBtn = document.getElementById('sendBatch');

tval.textContent = thresholdSlider.value;
thresholdSlider.addEventListener('input',()=>{ tval.textContent = Number(thresholdSlider.value).toFixed(3); });

let currentIdx = 0;
let slots = [];
let mediaStream, audioContext, mediaRecorder;
let armed = true;
let currentBatchAudioChunks = [];
const displayedWords = [];
// const API_URL="http://127.0.0.1:8000/transcribe";
const API_URL="https://speech.michaelwoodcock.duckdns.org/transcribe";
// Batch management variables
let currentBatchNumber = 1;
let currentBatchWords = [];
let wordsSinceLastSubmission = 0;
const SUBMISSION_INTERVAL = 5;
let isUploading = false;
let uploadQueue = [];
let isInBatchPause = false;
let batchPauseTimeout = null;
let batchAudioBlobs = []; // Store complete batch audio blobs
let autoScrollTimeout = null; // For auto-scrolling blank words
let batchStartTime = null; // Track when batch recording starts
let silenceStartTime = null; // Track when silence begins
let isProcessingBatch = false; // Prevent multiple batch completions

// --- Carousel functions ---
function makeSlot(idx,posClass){
  const el=document.createElement('div');
  el.className='slot';
  if(posClass==='pos-left'||posClass==='pos-right') el.classList.add('side');
  if(words[idx] === "") el.classList.add('blank');
  el.dataset.idx=idx;
  el.textContent=words[idx];
  el.classList.add(posClass);
  stage.appendChild(el);
  slots.push({el,idx});
  return el;
}

function findSlotByIdx(idx){ return slots.find(s=>s.idx===idx); }

function initSlots(){
  stage.innerHTML=''; slots=[]; currentIdx=0;
  makeSlot(0,'pos-center');
  if(words[1]) makeSlot(1,'pos-right');
  if(words[2]) makeSlot(2,'pos-off-right');
}
initSlots();

// --- Microphone init + RMS scrolling ---
async function initMic(){
  try{
    // Get MAXIMUM quality audio - try without specific sample rate first
    const audioConstraints = {
      channelCount: 1,
      echoCancellation: false,
      noiseSuppression: false,
      autoGainControl: false,
    };

    // Try with preferred sample rates
    for (const sampleRate of [48000, 44100, 16000]) {
      try {
        const constraintsWithSampleRate = {
          ...audioConstraints,
          sampleRate: { ideal: sampleRate, max: sampleRate }
        };
        mediaStream = await navigator.mediaDevices.getUserMedia({
          audio: constraintsWithSampleRate
        });
        console.log(`‚úÖ Acquired microphone at ${sampleRate}Hz`);
        break;
      } catch (e) {
        console.log(`‚ùå Failed to get ${sampleRate}Hz, trying next...`);
      }
    }
    
    if (!mediaStream) {
      // Final fallback - let browser choose without sample rate constraint
      mediaStream = await navigator.mediaDevices.getUserMedia({ 
        audio: audioConstraints 
      });
      console.log("‚úÖ Using browser-default audio quality");
    }
    
    // Start the FIRST batch recording
    startNewBatchRecording();
    
    // Setup audio context for RMS detection
    const track = mediaStream.getAudioTracks()[0];
    const settings = track.getSettings();
    const actualSampleRate = settings.sampleRate || 48000;
    
    audioContext = new (window.AudioContext||window.webkitAudioContext)({
      sampleRate: actualSampleRate,
      latencyHint: 'playback'
    });
    
    console.log(`üéöÔ∏è Audio context running at ${audioContext.sampleRate}Hz`);
    
    const source = audioContext.createMediaStreamSource(mediaStream);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.3; // Faster response for silence detection
    source.connect(analyser);
    const data = new Uint8Array(analyser.fftSize);

    let triggerCooldown = false;
    let lastRMS = 0;

    function check(){
      if (!audioContext) return;
      
      analyser.getByteTimeDomainData(data);
      let sum = 0;
      for(let i = 0; i < data.length; i++){ 
        const v = (data[i] - 128) / 128; 
        sum += v * v; 
      }
      const rms = Math.sqrt(sum / data.length);
      const thr = parseFloat(thresholdSlider.value);
      
      // Detect silence for batch completion
      if (rms < thr * 0.3 && lastRMS > thr * 0.5) {
        // Just became quiet after being loud
        if (!silenceStartTime && currentBatchWords.length > 0) {
          silenceStartTime = Date.now();
          console.log("üîá Silence detected, starting timer...");
        }
      } else if (rms > thr * 0.5) {
        // Became loud again, reset silence timer
        silenceStartTime = null;
      }
      
      // If we've been silent for 400ms and have words, complete the batch
      if (silenceStartTime && (Date.now() - silenceStartTime) > 400 && currentBatchWords.length > 0) {
        console.log("‚èπÔ∏è Silence threshold reached, completing batch");
        completeCurrentBatch();
        silenceStartTime = null;
      }
      
      if(rms > thr && armed && !triggerCooldown){ 
        console.log("Triggering scroll - RMS:", rms, "Threshold:", thr);
        triggerScroll(); 
        armed = false;
        triggerCooldown = true;
        
        setTimeout(() => { 
          triggerCooldown = false; 
        }, 300);
        
        setTimeout(() => { 
          armed = true; 
        }, 600);
      }
      else if(rms < thr * 0.4) {
        armed = true;
      }
      
      lastRMS = rms;
      requestAnimationFrame(check);
    }
    check();
  }catch(e){ 
    console.error("Microphone initialization failed:", e);
    alert("Could not access microphone. Please check permissions and try again.");
  }
}

// --- Start NEW MediaRecorder for each batch ---
function startNewBatchRecording() {
  currentBatchAudioChunks = [];
  batchStartTime = Date.now();
  
  if (mediaStream) {
    // Use FFmpeg-compatible formats in priority order
    const formatPriority = [
      'audio/webm;codecs=opus',    // Opus in WebM container (FFmpeg compatible)
      'audio/mp4',                 // AAC in MP4 container (FFmpeg compatible)  
      'audio/webm',                // Fallback WebM
    ];
    
    let selectedFormat = '';
    for (const format of formatPriority) {
      if (MediaRecorder.isTypeSupported(format)) {
        selectedFormat = format;
        console.log(`‚úÖ Using format: ${format}`);
        break;
      }
    }
    
    if (!selectedFormat) {
      selectedFormat = ''; // Let browser choose
      console.log("‚ö†Ô∏è No preferred format supported, using browser default");
    }
    
    const options = {
      mimeType: selectedFormat,
      audioBitsPerSecond: 128000 // Good quality for speech
    };
    
    mediaRecorder = new MediaRecorder(mediaStream, options);
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        currentBatchAudioChunks.push(event.data);
        console.log(`üì¶ Received audio chunk: ${event.data.size} bytes`);
      }
    };
    
    mediaRecorder.onstop = () => {
      console.log("üõë MediaRecorder stopped, processing batch...");
      
      // Create the complete batch audio blob from ALL chunks
      if (currentBatchAudioChunks.length > 0 && currentBatchWords.length > 0) {
        const batchBlob = new Blob(currentBatchAudioChunks, { type: options.mimeType });
        const duration = ((Date.now() - batchStartTime) / 1000).toFixed(2);
        console.log(`üíæ Batch ${currentBatchNumber} complete: ${batchBlob.size} bytes, ${duration}s`);
        
        // Store batch
        batchAudioBlobs[currentBatchNumber - 1] = batchBlob;
        
        // Log batch audio immediately
        logBatchAudio(currentBatchNumber, batchBlob, currentBatchWords);
        
        // Upload batch INSTANTLY
        uploadBatchAsync(currentBatchNumber, batchBlob, currentBatchWords);
        
        console.log("‚úÖ Batch processed");
        showStatus("‚úÖ Batch processed");
      }
      
      // Start next batch recording after a clean break
      setTimeout(() => {
        currentBatchNumber++;
        currentBatchWords = [];
        startNewBatchRecording();
      }, 100); // Small delay to ensure clean separation
    };
    
    // Start recording WITHOUT timeslice for cleaner batch separation
    mediaRecorder.start();
    console.log(`üéôÔ∏è Started NEW MediaRecorder for batch ${currentBatchNumber} (${selectedFormat || 'browser-default'})`);
  }
}

// --- Complete current batch immediately ---
function completeCurrentBatch() {
  if (mediaRecorder && mediaRecorder.state === 'recording' && currentBatchWords.length > 0) {
    console.log("üöÄ Completing batch immediately via stop() in 400ms...");
    setTimeout(() => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop(); // triggers onstop which processes the batch
        console.log("‚èπÔ∏è Batch stop triggered after delay");
      }
    }, 1000); // <-- 1000ms delay before stopping
  }
}

// --- Upload batch ASYNC and handle transcription ---
async function uploadBatchAsync(batchNumber, blob, words) {
  // Determine file extension based on MIME type
  let extension = 'webm'; // default
  if (blob.type.includes('mp4')) extension = 'mp4';
  if (blob.type.includes('ogg')) extension = 'ogg';
  if (blob.type.includes('opus')) extension = 'opus';
  
  const formData = new FormData();
  const wordsString = words.join('_');
  const filename = `batch_${batchNumber}_${wordsString}.${extension}`;
  
  formData.append("file", blob, filename);

  console.log(`üöÄ INSTANT Upload: ${filename} (${blob.size} bytes)`);
  
  // Fire and await the transcription response
  try {
    const response = await fetch(API_URL, {
      method: "POST", 
      body: formData
    });
    
    if (!response.ok) throw new Error(`Server error: ${response.status}`);
    
    const data = await response.json();
    console.log(`‚úÖ Batch ${batchNumber} upload complete:`, data);
    
    // Extract only what we need from the response
    const transcriptionData = {
      text: data.text || "",
      segments: data.segments || []
    };
    
    // Update the batch entry with transcription results
    updateBatchWithTranscription(batchNumber, transcriptionData, words);
    
    showStatus(`‚úÖ Batch ${batchNumber} transcribed!`);
    
  } catch (error) {
    console.error(`‚ùå Upload failed for batch ${batchNumber}:`, error);
    showStatus(`‚ùå Batch ${batchNumber} failed!`);
  }
}














// --- Update batch entry with transcription results ---
function updateBatchWithTranscription(batchNumber, transcriptionData, originalWords) {
  // Find the batch entry in the log
  const batchEntries = document.querySelectorAll('.batch-entry');
  const batchEntry = batchEntries[batchNumber - 1];
  
  if (!batchEntry) {
    console.warn(`Batch entry ${batchNumber} not found`);
    return;
  }
  
  // Remove loading indicator
  const loadingDiv = batchEntry.querySelector('.transcription-loading');
  if (loadingDiv) {
    loadingDiv.remove();
  }
  
  // Create transcription table
  const table = document.createElement('table');
  table.className = 'transcription-table';
  
  // Create table header
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th>#</th>
      <th>Expected</th>
      <th>You pronounced</th>
      <th>Start</th>
      <th>End</th>
      <th>Confidence</th>
    </tr>
  `;
  table.appendChild(thead);
  
  // Create table body
  const tbody = document.createElement('tbody');
  
  // Extract all words from segments with their timestamps
  const allTranscribedWords = [];
  transcriptionData.segments.forEach(segment => {
    if (segment.words && Array.isArray(segment.words)) {
      segment.words.forEach(word => {
        allTranscribedWords.push({
          word: word.word || "",
          start: word.start || 0,
          end: word.end || 0,
          confidence: word.probability || word.confidence || "N/A"
        });
      });
    }
  });
  
  console.log(`üîç All transcribed words with timestamps:`, allTranscribedWords);
  
  // Calculate average word duration to estimate timing
  const totalDuration = allTranscribedWords.length > 0 
    ? allTranscribedWords[allTranscribedWords.length - 1].end 
    : 0;
  const avgWordDuration = totalDuration / originalWords.length;
  
  console.log(`‚è±Ô∏è Estimated timing - Total: ${totalDuration.toFixed(2)}s, Avg per word: ${avgWordDuration.toFixed(2)}s`);
  
  // Group transcribed words by expected word positions using timestamps
  const wordGroups = [];
  let currentGroup = [];
  let currentGroupIndex = 0;
  
  allTranscribedWords.forEach((transcribedWord, index) => {
    const expectedEndTime = (currentGroupIndex + 1) * avgWordDuration;
    
    // If this word's start time is beyond the expected end time for current group, start new group
    if (transcribedWord.start > expectedEndTime && currentGroup.length > 0) {
      wordGroups.push({
        expectedWord: originalWords[currentGroupIndex] || "‚Äî",
        transcribedWords: [...currentGroup],
        start: currentGroup[0]?.start || 0,
        end: currentGroup[currentGroup.length - 1]?.end || 0
      });
      currentGroup = [];
      currentGroupIndex++;
    }
    
    currentGroup.push(transcribedWord);
  });
  
  // Add the last group
  if (currentGroup.length > 0 && currentGroupIndex < originalWords.length) {
    wordGroups.push({
      expectedWord: originalWords[currentGroupIndex] || "‚Äî",
      transcribedWords: [...currentGroup],
      start: currentGroup[0]?.start || 0,
      end: currentGroup[currentGroup.length - 1]?.end || 0
    });
  }
  
  // Fill in any missing groups
  for (let i = wordGroups.length; i < originalWords.length; i++) {
    wordGroups.push({
      expectedWord: originalWords[i],
      transcribedWords: [],
      start: 0,
      end: 0
    });
  }
  
  console.log(`üìä Word groups:`, wordGroups);
  
  // Calculate accuracy score - ONLY check for presence of 'H'
  let correctCount = 0;
  
  // Populate table rows based on word groups
  wordGroups.forEach((group, index) => {
    const transcribedText = group.transcribedWords.map(w => w.word).join(' ') || "‚Äî";
    
    // Check if ANY word in the group has 'H' - if so, the whole group is incorrect
    const hasH = group.transcribedWords.some(w => /h/i.test(w.word));
    const isCorrect = !hasH && transcribedText !== "‚Äî";
    
    if (isCorrect) {
      correctCount++;
    }
    
    const row = document.createElement('tr');
    
    // Calculate average confidence for the group
    const validConfidences = group.transcribedWords.filter(w => w.confidence !== "N/A" && w.confidence > 0);
    const avgConfidence = validConfidences.length > 0 
      ? validConfidences.reduce((sum, w) => sum + w.confidence, 0) / validConfidences.length 
      : "N/A";
    
    row.innerHTML = `
      <td class="time-cell">${index + 1}</td>
      <td class="word-cell">${group.expectedWord}</td>
      <td class="word-cell">${transcribedText}</td>
      <td class="time-cell">${group.start ? group.start.toFixed(2) + "s" : "‚Äî"}</td>
      <td class="time-cell">${group.end ? group.end.toFixed(2) + "s" : "‚Äî"}</td>
      <td class="time-cell">${avgConfidence !== "N/A" ? (avgConfidence * 100).toFixed(1) + "%" : "‚Äî"}</td>
    `;
    
    // Add visual feedback
    if (isCorrect) {
      row.style.background = 'rgba(0, 255, 0, 0.1)';
      row.title = "Perfect! No H sound detected";
    } else if (hasH) {
      row.style.background = 'rgba(255, 0, 0, 0.2)';
      row.title = "H sound detected - try making it silent";
    } else if (transcribedText === "‚Äî") {
      row.style.background = 'rgba(128, 128, 128, 0.1)';
      row.title = "No transcription for this word";
    }
    
    tbody.appendChild(row);
  });
  
  table.appendChild(tbody);
  
  // Calculate accuracy percentage
  const transcribedGroups = wordGroups.filter(group => group.transcribedWords.length > 0);
  const accuracy = transcribedGroups.length > 0 ? (correctCount / transcribedGroups.length) * 100 : 0;
  
  // Create score display
  const scoreDiv = document.createElement('div');
  scoreDiv.className = 'batch-score';
  
  let scoreClass = 'score-poor';
  if (accuracy >= 80) scoreClass = 'score-perfect';
  else if (accuracy >= 60) scoreClass = 'score-good';
  
  scoreDiv.classList.add(scoreClass);
  scoreDiv.innerHTML = `<strong>Silent H Accuracy: ${accuracy.toFixed(1)}%</strong> (${correctCount}/${transcribedGroups.length} words without H sound)`;
  
  // Add debug info
  const debugDiv = document.createElement('div');
  debugDiv.style.marginTop = '5px';
  debugDiv.style.fontSize = '12px';
  debugDiv.style.color = '#888';
  debugDiv.innerHTML = `<small>Whisper detected ${allTranscribedWords.length} word fragments, grouped into ${transcribedGroups.length} expected words</small>`;
  
  // Add full transcription text
  const fullTextDiv = document.createElement('div');
  fullTextDiv.style.marginTop = '10px';
  fullTextDiv.style.fontSize = '14px';
  fullTextDiv.style.color = '#ccc';
  fullTextDiv.innerHTML = `<strong>Full Transcription:</strong> ${transcriptionData.text || "No transcription available"}`;
  
  // Insert the elements before the waveform
  const waveform = batchEntry.querySelector('.waveform');
  if (waveform) {
    batchEntry.insertBefore(scoreDiv, waveform);
    batchEntry.insertBefore(debugDiv, waveform);
    batchEntry.insertBefore(table, waveform);
    batchEntry.insertBefore(fullTextDiv, waveform);
  } else {
    batchEntry.appendChild(scoreDiv);
    batchEntry.appendChild(debugDiv);
    batchEntry.appendChild(table);
    batchEntry.appendChild(fullTextDiv);
  }
}















// --- Word tracking (no individual audio) ---
function trackWord(idx){
  if(!mediaStream) return;
  
  // Only track actual words, not blank separators
  if (words[idx] !== "") {
    currentBatchWords.push(words[idx]);
    displayedWords.push({word:words[idx], idx, time:performance.now()});
    console.log(`üìù Tracked word: ${words[idx]} for batch ${currentBatchNumber}`);
    
    // Reset silence detection when we get a new word
    silenceStartTime = null;
    
    // Check if we've reached the submission interval
    if (currentBatchWords.length >= SUBMISSION_INTERVAL) {
      console.log("üì¶ 5 words reached, completing batch");
      setTimeout(() => completeCurrentBatch(), 100); // Small delay to capture final audio
    }
  }
}

// --- Log complete batch audio ---
function logBatchAudio(batchNumber, blob, words) {
  const batchEntry = document.createElement('div');
  batchEntry.className = "batch-entry";
  
  const batchTitle = document.createElement("div");
  batchTitle.className = "batch-title";
  batchTitle.textContent = `Batch ${batchNumber}: ${words.join(' ')}`;
  
  const playBtn = document.createElement("button");
  playBtn.textContent = "üîä Play Batch";
  playBtn.className = "playBtn";
  
  const waveDiv = document.createElement("div");
  waveDiv.className = "waveform";

  // Create loading indicator for transcription
  const loadingDiv = document.createElement('div');
  loadingDiv.className = "transcription-loading";
  loadingDiv.textContent = "‚è≥ Transcribing...";
  loadingDiv.style.margin = '10px 0';

  batchEntry.appendChild(batchTitle);
  batchEntry.appendChild(playBtn);
  batchEntry.appendChild(loadingDiv); // Add loading indicator
  batchEntry.appendChild(waveDiv);
  
  // Try WaveSurfer
  try {
    const ws = WaveSurfer.create({
      container: waveDiv,
      waveColor: '#ffa500',
      progressColor: '#ffcc00',
      height: 80,
      normalize: true,
      barWidth: 2,
      barGap: 1
    });
    
    ws.loadBlob(blob);
    playBtn.onclick = () => ws.playPause();
  } catch (error) {
    console.error("WaveSurfer failed:", error);
    // Fallback to audio element
    const audioUrl = URL.createObjectURL(blob);
    const audioElement = document.createElement('audio');
    audioElement.src = audioUrl;
    audioElement.controls = true;
    batchEntry.appendChild(audioElement);
  }
  
  logDiv.appendChild(batchEntry);
  logDiv.scrollTop = logDiv.scrollHeight;
}

// --- Carousel scroll ---
let animating=false;
function triggerScroll(){
  if(animating || currentIdx>=words.length) return;
  animating=true;
  trackWord(currentIdx);

  const newOffRightIdx = currentIdx+3;
  if(words[newOffRightIdx] && !findSlotByIdx(newOffRightIdx)) makeSlot(newOffRightIdx,'pos-off-right');

  slots.forEach(s=>{
    const el=s.el; el.classList.remove('pos-left','pos-center','pos-right','pos-off-right','pos-off-left');
    const idx=s.idx;
    if(idx===currentIdx-1) el.classList.add('pos-off-left');
    else if(idx===currentIdx) el.classList.add('pos-left','side');
    else if(idx===currentIdx+1) el.classList.add('pos-center');
    else if(idx===currentIdx+2) el.classList.add('pos-right','side');
    else if(idx===currentIdx+3) el.classList.add('pos-off-right');
    else el.classList.add('pos-off-left');
  });

  setTimeout(()=>{
    slots = slots.filter(s=>{ if(s.el.classList.contains('pos-off-left')){ stage.removeChild(s.el); return false; } return true; });
    currentIdx++;
    slots.forEach(s=>{
      s.el.classList.remove('pos-left','pos-center','pos-right','pos-off-right','pos-off-left');
      if(s.idx===currentIdx-1) s.el.classList.add('pos-left','side');
      if(s.idx===currentIdx) s.el.classList.add('pos-center');
      if(s.idx===currentIdx+1) s.el.classList.add('pos-right','side');
      if(s.idx===currentIdx+2) s.el.classList.add('pos-off-right');
    });
    animating=false;
    
    // Check if we've reached a blank word (batch separator)
    if (currentIdx < words.length && words[currentIdx] === "") {
      // Auto-scroll after 1 second (faster!)
      console.log("‚è∏Ô∏è Blank word - auto-scrolling in 1 second");
      showStatus("‚è∏Ô∏è Auto-advancing in 1 second");
      autoScrollTimeout = setTimeout(() => {
        console.log("üîÑ Auto-scrolling from blank word");
        triggerScroll();
      }, 500); // NOTE: THIS IS THE time before scrolling
    }
    
    showProgress();
  }, 450);
}

// --- Show status message ---
function showStatus(message) {
  let statusDiv = document.querySelector('.status');
  if (!statusDiv) {
    statusDiv = document.createElement('div');
    statusDiv.className = 'status';
    document.body.appendChild(statusDiv);
  }
  statusDiv.textContent = message;
  setTimeout(() => {
    if (statusDiv.textContent === message) {
      statusDiv.remove();
    }
  }, 1000); // Shorter status display
}

// --- Show progress ---
function showProgress() {
  let progressDiv = document.querySelector('.progress');
  if (!progressDiv) {
    progressDiv = document.createElement('div');
    progressDiv.className = 'progress';
    document.body.appendChild(progressDiv);
  }
  
  let batchDiv = document.querySelector('.batch-indicator');
  if (!batchDiv) {
    batchDiv = document.createElement('div');
    batchDiv.className = 'batch-indicator';
    document.body.appendChild(batchDiv);
  }
  
  const actualWordCount = words.filter((word, idx) => idx <= currentIdx && word !== "").length;
  const nextBatchIn = SUBMISSION_INTERVAL - (currentBatchWords.length % SUBMISSION_INTERVAL);
  
  progressDiv.textContent = `Words: ${actualWordCount}/${originalWords.length} | Next batch in: ${nextBatchIn} words`;
  batchDiv.textContent = `Current Batch: ${currentBatchNumber} (${currentBatchWords.length} words)`;
}

// --- Send full audio to server ---
sendBatchBtn.onclick = async ()=>{
  if(!mediaRecorder) return alert("No recording active!");
  sendBatchBtn.disabled=true;

  try {
    // Complete current batch if it has words
    if (currentBatchWords.length > 0) {
      completeCurrentBatch();
    }
    
    showStatus("Final batch requested...");
    
  }catch(e){ 
    console.error("Upload failed:", e);
    showStatus("Upload failed!");
    alert("Upload failed: " + e.message);
  }
  finally{ 
    sendBatchBtn.disabled=false; 
  }
};

// --- Start microphone & scrolling ---
initMic();
stage.addEventListener('click',()=>triggerScroll());
window.addEventListener('keydown', e=>{
  if(e.code==='Space'){
    e.preventDefault(); 
    triggerScroll();
  }
});

// Initial progress display
showProgress();
</script>
</body>
</html>
